#我们想对外开放某些功能，就可以将这些功能在代理类中被引用，如此一来，屏蔽了我们不想外露的功能，只将我们想开放的功能开放出来。亦即委托类中其实是可以有很多方法的，很多功能的，我们可以酌情对外开放，代理类犹如一道大门，将委托类与外部调用者隔绝开来，只将部分功能赋予这个大门，来代替委托类行使这个功能，哪怕最终还是要牵扯到自身（因为最终还是要调用委托类的对应方法实现）。

#关键点
（1）代理类与委托类实现同一接口
（2）在委托类中实现功能，在代理类的方法中中引用委托类的同名方法
（3）外部类调用委托类某个方法时，直接以接口指向代理类的实例，这正是代理的意义所在：屏蔽。
#代理模式场景描述
（1）当我们想要隐藏某个类时，可以为其提供代理类
（2）当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中金进行权限判断来进行不同权限的功能调用）
（3）当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行）

#代理模式虽然实现了调用者与委托类之间的强耦合，但是却增加了代理类与委托类之间的强耦合（在代理类中显式调用委托类的方法），而且增加代理类之后明显会增加处理时间，拖慢处理时间。
